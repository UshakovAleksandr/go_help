package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp" // 1
	"strings"
)

//В строке 1 подключаем пакет regexp, который содержит типы и функции для работы с регулярными выражениями.
//В строке 2 происходит инициализация переменной регулярного выражения. Я использовал метод-конструктор:
//MustCompile(str string) (*Regex)
//Это значит, что в случае ошибки в синтаксисе регулярного выражения будет вызвана паника.
//
//Используя метод-конструктор:
//
//Compile(str string) (*Regex, error)
//Можно избежать такой проблемы. Он вернёт указатель на регулярное выражение и ошибку, которую вы можете обработать. Так как мой пример достаточно статичен и не будет меняться, я оставлю MustCompile.
//
//В строке 3 инициализируем строку, на которой будем проверять регулярное выражение.
//Строка 4 — используя метод FindString, мы находим первую подстроку, которая подходит под наш шаблон.
//Строка 5 — используем метод FindAllStringSubmatch для поиска всех подстрок и для дополнительного извлечения данных по группам захвата.
//Что такое группа захвата, рассмотрим далее. Но если кратко, то в данном примере группа захвата использовалась для получения имени — слова, идущего после фразы "Hello, ".

func main() {
	re := regexp.MustCompile(`Hello, ([A-Z]{1}[a-z]+)`) // 2

	testStr := "test...^&* test test Hello, Foobar #$#$#$#$####" // 3

	fmt.Println(re.FindString(testStr)) // 4

	submatch := re.FindAllStringSubmatch(testStr, -1) // 5
	fmt.Println(submatch[0][1])
}

// Hello, Foobar
// Foobar

//Как вы уже заметили, регулярное выражение строится на основе шаблона, который является обычной строкой со странными инструкциями.
//
//Наш паттерн в примере выглядит следующим образом:
//
//Hello, ([A-Z]{1}[a-z]+)
//Составные части представленного регулярного выражения:
//
//"Hello, " — обычная строка, то есть регулярное выражение ожидает именно такой текст в искомой подстроке.
//В круглых скобках указана группа захвата — подвыражение из подстроки, которое мы можем захотеть использовать.
//[A-Z]{1} — в квадратных скобках указывают классы символов. В данном случае мы ожидаем символы ASCII от A до Z, то есть любую большую букву латинского алфавита. В фигурных скобках мы указали ожидаемое количество элементов — 1. Мы ожидаем, что имя начинается с большой буквы.
//[a-z]+ — ещё один класс символов, в этот раз мы ожидаем любую маленькую букву латинского алфавита. Знак плюс (+) в конце указывает, что мы ожидаем 1 символ или больше.
//Как вы заметили, класс символов является одним из важнейших элементов регулярных выражений. Если бы у вас не было регулярных выражений, как бы выглядела проверка соответствия шаблону? Потребовался бы цикл, идущий по символам строки, внутри — цикл идущий по всем большим буквам латинского алфавита. И мы бы проверяли, совпадает ли текущий символ строки с какой-нибудь литерой. Другими словами, проверка строк без регулярных выражений требовала бы очень много повторяющегося кода.
//
//У класса символов есть некоторые особенности, о которых стоит знать:
//
//Он может принимать обычные символы и метасимволы (специальные сокращения).
//Порядок символов и метасимволов не влияет на результат работы регулярного выражения.
//Нужно не забывать указать ожидаемое количество символов и уровень «жадности» данного класса символов.
//Далее я приведу список самых распространённых примеров регулярных выражений:
//
//.	Точка значит любой один символ.
//.*	Точка, звездочка — любой символ, любое количество от 0 и до бесконечности.
//[\s]	Пробел.
//[\S]	Любой символ, кроме пробела.
//[\w]
//Заменяет собой конструкцию a-zA-Z0-9_. То есть ожидается появление таких символов: малые и большие буквы латинского алфавита, цифры и знак нижнего подчеркивания.
//
//Полезен для поиска слов в тексте.
//
//[\W]	Инверсия с \w — будет искать всё, кроме малых и больших буквы латинского алфавита, цифр и знака нижнего подчеркивания.
//[helo]+	Ищет подстроку, которая будет состоять только из букв "h", "e", "l", "o". Порядок может быть другой, количество каждой из букв в найденном слове не важно, но должна быть хотя бы одна из указанных букв.
//^[w][\w][d]$
//Проверяет, соответствует ли строка следующим условиям:
//
//Первая буква должна быть "w", далее любые большие и малые буквы, цифры, знак нижнего подчёркивания.
//Последний символ обязательно "d".
//За символом ^ мы указываем, с чего должна начинаться строка.
//Перед символом $ указываем, чем строка должна заканчиваться.
//Важно помнить: указывая обязательные префикс и суффикс строки, мы больше не можем искать подстроки с совпадением, вся передаваемая строка должна соответствовать условиям регулярного выражения.
//
//Теперь более детально о группах захвата (части регулярного выражения в круглых скобках). Как уже говорилось ранее, это части найденной подстроки, которые нам могут пригодиться по отдельности. Регулярным выражением с группами захвата можно извлечь части найденной подстроки.
//
//Для этого используются следующие методы структуры regexp.Regex{}:
//
//FindAllStringSubmatch(s string, n int) [][]string
//FindAllStringSubmatchIndex(s string, n int) [][]int
//FindAllSubmatch(b []byte, n int) [][][]byte
//FindAllSubmatchIndex(b []byte, n int) [][]int
//FindReaderSubmatchIndex(r io.RuneReader) []int
//FindStringSubmatch(s string) []string
//FindStringSubmatchIndex(s string) []int
//FindSubmatch(b []byte) [][]byte
//FindSubmatchIndex(b []byte) []int

//В своих примерах я использовал в основном функцию FindAllStringSubmatch, так как она принимает на вход строку и возвращает срез срезов строк. Наиболее удобный формат для примеров.
//
//func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string
//Данный метод принимает на вход строку, в которой будем искать подстроки. Второй параметр для того, чтобы ограничить кол-во найденных подстрок. Просто укажите -1 (минус один) чтобы считывать все найденные совпадения без ограничений.
//
//Результат выполнения срез срезов строк. В данной структуре группируются найденные данные для групп захвата.
//
//Примеры использования регулярных выражений
//Проверка соответствия паттерну на примере задачи проверки валидного адреса электронной почты. В данном примере используется упрощённый вариант регулярного выражения для электронных адресов, который позволит понять суть, но верифицировать далеко не все варианты почтовых адресов.

func ex1() {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Введите email: ")
	str, err := reader.ReadString('\n')
	if err != nil {
		panic(err)
	}

	// удаляем символ перевода на новую строку
	str = strings.TrimSpace(str)

	emailRegex := regexp.MustCompile(`^[a-zA-Z][\w.-]+@[\w.-]+$`)
	isMatch := emailRegex.MatchString(str)

	fmt.Printf("Ввод \"%s\", совпадение с шаблоном: %v", str, isMatch)
}

//Для проверки кода можно использовать такие примеры:
//
//hi###7777@main.ru
//4cats@gmail.com
//_4cats@gmail.com
//my4cats@gmail.com

//Ещё один пример использования регулярных выражений — проверка требований к паролю. Длина не менее N, наличие прописных (больших) и строчных (малых) букв, наличие цифр, наличие спецсимволов.

const (
	minLength = 8
)

func ex2() {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Введите пароль " +
		"(должен содержать строчные и прописные буквы, " +
		"цифры, по крайней мере один спец.символ " +
		"и быть длинной не менее 8 символов): ")
	str, err := reader.ReadString('\n')
	if err != nil {
		panic(err)
	}

	// удаляем символ перевода на новую строку
	str = strings.TrimSpace(str)

	// проверка длины пароля
	lenRegex := regexp.MustCompile(fmt.Sprintf(`^.{%d,}$`, minLength))
	if !lenRegex.MatchString(str) {
		fmt.Printf("Ошибка! Длина пароля менее %d\n", minLength)
		return
	}

	// проверка наличия обязательных символов
	if !regexp.MustCompile(`[a-z]+`).MatchString(str) {
		fmt.Println("Ошибка! Пароль должен содержать строчные буквы")
		return
	}
	if !regexp.MustCompile(`[A-Z]+`).MatchString(str) {
		fmt.Println("Ошибка! Пароль должен содержать прописные буквы")
		return
	}
	if !regexp.MustCompile(`[0-9]+`).MatchString(str) {
		fmt.Println("Ошибка! Пароль должен содержать цифры")
		return
	}

	mostPopularPassword := []string{
		"Qq123456",
		"Qwerty123",
	}
	join := strings.Join(mostPopularPassword, "|")
	weakPassRegex := regexp.MustCompile(fmt.Sprintf("^(%s)$", join))
	if weakPassRegex.MatchString(str) {
		fmt.Println("Предупреждение! Очень слабый пароль, придумайте другой")
		return
	}

	specCharRegex := regexp.MustCompile(`[!@#$%^&*()\-=+,./\\]+`)
	if !specCharRegex.MatchString(str) {
		fmt.Println("Ошибка! Пароль должен содержать спец.символ")
		return
	}

	fmt.Println("Введен корректный пароль")
}

// Другой пример — поиск подстрок по паттерну. В данном примере поиск всех CSS классов в HTML документе.

func ex3() {
	contentBytes, err := os.ReadFile("./index.html")
	if err != nil {
		panic(err)
	}

	re := regexp.MustCompile(`class="([a-zA-Z0-9_\-\s]+)"`)

	submatches := re.FindAllStringSubmatch(string(contentBytes), -1)

	for _, s := range submatches {
		classes := strings.Split(s[1], " ")
		for _, c := range classes {
			fmt.Println("Найден класс", c)
		}
	}
}

//Символ	Что означает
//\d	Любая цифра. То же самое, что [0-9]
//\D	Любой символ, кроме цифры. То же самое, что [^0-9]
//\w	Любая буква, цифра и нижнее подчёркивание
//\W	Любой символ, кроме буквы, цифры и нижнего подчёркивания
//\s	Любой пробельный символ (пробел, новая строка, табуляция, возврат каретки и тому подобное)
//\S	Любой символ, кроме пробельного
//\A	Начало строки. То же самое, что ^
//\Z	Конец строки. То же самое, что $
//\b	Начало или конец слова
//\B	Середина слова
//\n, \t\, \r	Стандартные строковые обозначения: новая строка, табуляция, возврат каретки
